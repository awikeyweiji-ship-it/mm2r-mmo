import \'package:flutter/foundation.dart\' show kIsWeb;\nimport \'package:shared_preferences/shared_preferences.dart\';\nimport \'package:http/http.dart\' as http;\nimport \'dart:developer\' as developer;\nimport \'dart:math\' as math;\n\nclass AppConfig {\n  static const String kHttpBaseUrlKey = \'http_base_url\';\n  static const String kRoomIdKey = \'room_id\';\n  static const String kPlayerNameKey = \'player_name\';\n\n  static Future<String> getHttpBaseUrl() async {\n    final prefs = await SharedPreferences.getInstance();\n    return prefs.getString(kHttpBaseUrlKey) ?? \'http://localhost:8080\';\n  }\n\n  static Future<void> setHttpBaseUrl(String url) async {\n    final prefs = await SharedPreferences.getInstance();\n    await prefs.setString(kHttpBaseUrlKey, url);\n  }\n\n  // ... (get/set for RoomId and PlayerName remain the same) ...\n  static Future<String> getRoomId() async {\n    final prefs = await SharedPreferences.getInstance();\n    return prefs.getString(kRoomIdKey) ?? \'poc_world\';\n  }\n\n  static Future<void> setRoomId(String roomId) async {\n    final prefs = await SharedPreferences.getInstance();\n    await prefs.setString(kRoomIdKey, roomId);\n  }\n\n  static Future<String> getPlayerName() async {\n    final prefs = await SharedPreferences.getInstance();\n    return prefs.getString(kPlayerNameKey) ?? \'Guest_${math.Random().nextInt(999)}\';\n  }\n\n  static Future<void> setPlayerName(String name) async {\n    final prefs = await SharedPreferences.getInstance();\n    await prefs.setString(kPlayerNameKey, name);\n  }\n\n  static List<String> _getWebCandidates() {\n    if (!kIsWeb) return [];\n\n    final uri = Uri.base;\n    final host = uri.host;\n    final candidates = <String>{}; // Use a Set to avoid duplicates\n\n    // Pattern 1: ---<port>---. ... .devshell.app\n    final portPattern1 = RegExp(r\'--(\\d+)--\');\n    if (host.contains(portPattern1)) {\n        candidates.add(uri.replace(host: host.replaceAll(portPattern1, \'--8080--\')).origin);\n    }\n    \n    // Pattern 2: -<port>-. ... .devshell.app\n    final portPattern2 = RegExp(r\'-(?!-)(\\d+)-\');\n     if (host.contains(portPattern2)) {\n        candidates.add(uri.replace(host: host.replaceAll(portPattern2, \'-8080-\')).origin);\n    }\n
    // Pattern 3: /proxy/<port>/\n    if (uri.path.contains(\'/proxy/\')) {\n        final newPath = uri.path.replaceAll(RegExp(r\'/proxy/\\d+/\'), \'/proxy/8080/\');\n        candidates.add(uri.replace(path: newPath).toString());\n    } \n    // It is very unlikely that we have a port in the query params for IDX, so we skip it.\n\n    developer.log(\'Web candidates generated: ${candidates.toList()}\', name: \'AppConfig.WebDetect\');\n    return candidates.toList();\n  }\n\n  static Future<Map<String, dynamic>> discoverAndSetBaseUrl() async {\n    String? savedUrl = await getHttpBaseUrl();\n    final List<String> candidates = [];\n\n    if (kIsWeb) {\n      candidates.addAll(_getWebCandidates());\n    }\n\n    // Always add the saved URL as a candidate, unless it is localhost.\n    if (savedUrl != null && !savedUrl.contains(\'localhost\')) {\n        candidates.add(savedUrl);\n    }\n    \n    final uniqueCandidates = candidates.toSet().toList();\n    developer.log(\'All candidates: $uniqueCandidates\', name: \'AppConfig.Discovery\');\n\n    for (final candidate in uniqueCandidates) {\n        if (candidate.contains(\'localhost\') || candidate.isEmpty) continue;\n\n        developer.log(\'Probing candidate: $candidate\', name: \'AppConfig.Discovery\');\n        try {\n            final healthUri = Uri.parse(\'$candidate/health\');\n            final response = await http.get(healthUri).timeout(const Duration(seconds: 2));\n            if (response.statusCode == 200) {\n                developer.log(\'Probe SUCCESS: $candidate\', name: \'AppConfig.Discovery\');\n                await setHttpBaseUrl(candidate);\n                return {\'success\': true, \'baseUrl\': candidate, \'reason\': \'Discovered via probe.\'};\n            }\n        } catch (e) {\n            developer.log(\'Probe FAILED for $candidate: $e\', name: \'AppConfig.Discovery\');\n        }\n    }\n    await setHttpBaseUrl(\'\'); // Clear the invalid URL\n    return {\n      \'success\': false, \n      \'baseUrl\': \'\', \n      \'reason\': \'No viable candidate found. Probed: ${uniqueCandidates.take(3).join(\', \')}\'\n    };\n  }\n\n  static Future<String> deriveWsUrl() async {\n    final httpUrl = await getHttpBaseUrl();\n    if (httpUrl.isEmpty) return \'\';\n    \n    final roomId = await getRoomId();\n    final playerName = await getPlayerName();\n    final playerColor = math.Random().nextInt(0xFFFFFF).toRadixString(16).padLeft(6, \'0\');\n\n    final Uri uri = Uri.parse(httpUrl);\n    final bool isSecure = uri.scheme == \'https\';\n    \n    final queryParams = {\n      \'roomId\': roomId,\n      \'playerName\': playerName,\n      \'playerColor\': playerColor\n    };\n    \n    final wsUri = Uri(\n      scheme: isSecure ? \'wss\' : \'ws\',\n      host: uri.host,\n      port: uri.port,\n      path: \'/ws\',\n      queryParameters: queryParams\n    );\n    \n    return wsUri.toString();\n  }\n}\n