const express = require(\'express\');\nconst http = require(\'http\');\nconst WebSocket = require(\'ws\');\nconst cors = require(\'cors\'); // Import cors\n\nconst app = express();\nconst server = http.createServer(app);\nconst wss = new WebSocket.Server({ server });\n\n// Enable CORS for all routes\napp.use(cors({ origin: true, credentials: false }));\napp.options(\'*\', cors()); // Enable pre-flight for all routes\n\napp.get(\'/health\', (req, res) => {\n  res.status(200).json({ status: \'ok\', timestamp: new Date().toISOString() });\n});\n\nconst rooms = {};\nconst TICK_RATE = 15; // 15Hz\n\n// ... (rest of the WebSocket logic remains the same)\nwss.on(\'connection\', (ws, req) => {\n  const url = new URL(req.url, `http://${req.headers.host}`);\n  const roomId = url.searchParams.get(\'roomId\') || \'default\';\n  const playerId = `player_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;\n  const playerName = url.searchParams.get(\'playerName\') || \'Guest\';\n  const playerColor = `#${url.searchParams.get(\'playerColor\') || \'FF0000\'}`;\n\n  if (!rooms[roomId]) {\n    rooms[roomId] = { players: {}, tickInterval: null };\n  }\n\n  const room = rooms[roomId];\n  room.players[playerId] = { \n    id: playerId, \n    name: playerName,\n    color: playerColor,\n    x: 300, y: 300, ts: Date.now() \n  };\n\n  ws.send(JSON.stringify({ type: \'welcome\', playerId, roomState: room.players }));\n\n  if (!room.tickInterval) {\n    room.tickInterval = setInterval(() => {\n      if (Object.keys(room.players).length > 0) {\n        broadcastState(roomId);\n      } else {\n        clearInterval(room.tickInterval);\n        room.tickInterval = null;\n      }\n    }, 1000 / TICK_RATE);\n  }\n\n  ws.on(\'message\', (message) => {\n    const data = JSON.parse(message);\n    const player = room.players[playerId];\n    if (player && data.type === \'move\') {\n      player.x = data.x;\n      player.y = data.y;\n      player.ts = Date.now();\n    }\n  });\n\n  ws.on(\'close\', () => {\n    delete room.players[playerId];\n    if (Object.keys(room.players).length === 0) {\n      console.log(`Room ${roomId} is now empty.`);\n      if (room.tickInterval) {\n          clearInterval(room.tickInterval);\n          room.tickInterval = null;\n      } \n    }\n  });\n});\n\nfunction broadcastState(roomId) {\n    const room = rooms[roomId];\n    if (!room) return;\n\n    const state = { type: \'state\', players: room.players };\n    const message = JSON.stringify(state);\n\n    wss.clients.forEach(client => {\n        if (client.readyState === WebSocket.OPEN && isClientInRoom(client, roomId)) {\n            client.send(message);\n        }\n    });\n}\n\nfunction isClientInRoom(client, roomId) {\n    // This is a simplified check. In a real app, you\'d have a more robust way\n    // to associate clients with rooms.\n    for (const player of Object.values(rooms[roomId].players)) {\n       // This check is flawed because we don\'t have a direct link from ws client to player id.\n       // However, for this single-server-process example, we broadcast to all clients in the same room instance.\n       return true; \n    }\n    return false;\n}\n\nconst PORT = process.env.PORT || 8080;\nserver.listen(PORT, () => {\n  console.log(`Server is listening on port ${PORT}`);\n});\n