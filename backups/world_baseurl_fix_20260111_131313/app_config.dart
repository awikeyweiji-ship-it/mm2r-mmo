import \'package:flutter/foundation.dart\' show kIsWeb;\nimport \'package:shared_preferences/shared_preferences.dart\';\nimport \'package:http/http.dart\' as http;\nimport \'dart:developer\' as developer;\nimport \'dart:math\' as math;\n\nclass AppConfig {\n  static const String kHttpBaseUrlKey = \'http_base_url\';\n  static const String kRoomIdKey = \'room_id\';\n  static const String kPlayerNameKey = \'player_name\';\n\n  static Future<String> getHttpBaseUrl() async {\n    final prefs = await SharedPreferences.getInstance();\n    return prefs.getString(kHttpBaseUrlKey) ?? \'http://localhost:8080\';\n  }\n\n  static Future<void> setHttpBaseUrl(String url) async {\n    final prefs = await SharedPreferences.getInstance();\n    await prefs.setString(kHttpBaseUrlKey, url);\n  }\n\n  static Future<String> getRoomId() async {\n    final prefs = await SharedPreferences.getInstance();\n    return prefs.getString(kRoomIdKey) ?? \'poc_world\';\n  }\n\n  static Future<void> setRoomId(String roomId) async {\n    final prefs = await SharedPreferences.getInstance();\n    await prefs.setString(kRoomIdKey, roomId);\n  }\n\n  static Future<String> getPlayerName() async {\n    final prefs = await SharedPreferences.getInstance();\n    return prefs.getString(kPlayerNameKey) ?? \'Guest_${math.Random().nextInt(999)}\';\n  }\n\n  static Future<void> setPlayerName(String name) async {\n    final prefs = await SharedPreferences.getInstance();\n    await prefs.setString(kPlayerNameKey, name);\n  }\n\n  static String? _deriveBaseUrlForWeb() {\n    if (!kIsWeb) return null;\n\n    final Uri uri = Uri.base;\n    developer.log(\'Uri.base detected: $uri\', name: \'AppConfig.WebDetect\');\n    \n    // Standard IDX forwarded URL pattern: https://...-<port>-...devshell.app/\n    final host = uri.host;\n    final portRegexp = RegExp(r\'-\\d+-\');\n\n    if (host.contains(portRegexp)) {\n      final newHost = host.replaceAll(portRegexp, \'-8080-\');\n      final candidateUrl = uri.replace(host: newHost).origin;\n      developer.log(\'Derived Web candidate: $candidateUrl\', name: \'AppConfig.WebDetect\');\n      return candidateUrl;\n    }\n    return null;\n  }\n\n  static Future<Map<String, dynamic>> discoverAndSetBaseUrl() async {\n    String? currentUrl = await getHttpBaseUrl();\n    final List<String> candidates = [];\n\n    if (kIsWeb) {\n      final webCandidate = _deriveBaseUrlForWeb();\n      if (webCandidate != null) {\n        candidates.add(webCandidate);\n      }\n    }\n\n    // Fallback or for non-web environments (less reliable)\n    const String previewUrlEnv = String.fromEnvironment(\'PREVIEW_URL\');\n    if (previewUrlEnv.isNotEmpty) {\n        final uri = Uri.parse(previewUrlEnv);\n        candidates.add(uri.replace(port: 8080).origin);\n    }\n    \n    // If current URL is localhost, we MUST find a replacement.\n    if (currentUrl.contains(\'localhost\') || currentUrl.isEmpty) {\n        developer.log(\'Current URL is localhost/empty, forcing discovery...\', name: \'AppConfig.Discovery\');\n        for (final candidate in candidates.toSet()) { // .toSet() for uniqueness\n            developer.log(\'Probing candidate: $candidate\', name: \'AppConfig.Discovery\');\n            try {\n                final healthUri = Uri.parse(\'$candidate/health\');\n                final response = await http.get(healthUri).timeout(const Duration(seconds: 2));\n                if (response.statusCode == 200) {\n                    developer.log(\'Probe SUCCESS: $candidate\', name: \'AppConfig.Discovery\');\n                    await setHttpBaseUrl(candidate);\n                    return {\'success\': true, \'baseUrl\': candidate, \'reason\': \'Discovered via probe.\'};\n                }\n            } catch (e) {\n                developer.log(\'Probe FAILED for $candidate: $e\', name: \'AppConfig.Discovery\');\n            }\n        }\n        return {\'success\': false, \'baseUrl\': currentUrl, \'reason\': \'No viable candidate found. Candidates: ${candidates.join(\', \')}\'};\n    } else {\n       developer.log(\'Using existing non-local URL: $currentUrl\', name: \'AppConfig.Discovery\');\n       return {\'success\': true, \'baseUrl\': currentUrl, \'reason\': \'Using persisted non-local URL.\'};\n    }\n  }\n\n  static Future<String> deriveWsUrl() async {\n    final httpUrl = await getHttpBaseUrl();\n    if (httpUrl.isEmpty || httpUrl.contains(\'localhost\')) return \'\'; // Prevent connection to localhost\n    \n    final roomId = await getRoomId();\n    final playerName = await getPlayerName();\n    final playerColor = math.Random().nextInt(0xFFFFFF).toRadixString(16).padLeft(6, \'0\');\n\n    final Uri uri = Uri.parse(httpUrl);\n    final bool isSecure = uri.scheme == \'https\';\n    \n    final queryParams = {\n      \'roomId\': roomId,\n      \'playerName\': playerName,\n      \'playerColor\': playerColor\n    };\n    \n    final wsUri = Uri(\n      scheme: isSecure ? \'wss\' : \'ws\',\n      host: uri.host,\n      port: uri.port,\n      path: \'/ws\',\n      queryParameters: queryParams\n    );\n    \n    return wsUri.toString();\n  }\n}\n